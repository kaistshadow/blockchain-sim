#ifndef SOCKET_H
#define SOCKET_H

#include <ev++.h>
#include <list>
#include <string.h>
#include <memory>

#include "Peer.h"

#define DEFAULT_SOCKET_PORT 3456
#define BACKLOG 100     /* how many pending connections queue will hold */

namespace libBLEEP {

    class ListenSocketManager;
    class ConnectSocketManager;
    class DataSocketManager;
    class Message;


    enum class SocketEventEnum {
        none,
        readEvent,
        writeEvent,
        closeEvent
    };

    enum class SocketTypeEnum {
        none,
        ListenSocket,
        ConnectSocket,
        DataSocket
    };

    enum RECV_STATUS {
        RECV_IDLE = 0,
        RECV_MSG = 1,
        RECV_NONE = 2,
    };

    struct WriteMsg {
        char       *data;
        ssize_t len;
        ssize_t pos;
        std::pair< PeerId, std::shared_ptr<Message>> msgInfo;

        WriteMsg (const char *bytes, ssize_t nbytes) {
            pos = 0;
            len = nbytes;
            data = new char[nbytes];
            memcpy(data, bytes, nbytes);
            msgInfo.second = nullptr;
        }

        WriteMsg (const char *bytes, ssize_t nbytes, PeerId dest, std::shared_ptr<Message> msg) {
            pos = 0;
            len = nbytes;
            data = new char[nbytes];
            memcpy(data, bytes, nbytes);

            msgInfo.first = dest;
            msgInfo.second = msg;
        }

        virtual ~WriteMsg () {
            delete [] data;
        }

        char *dpos() {
            return data + pos;
        }

        ssize_t nbytes() {
            return len - pos;
        }
    };

    class SocketRecvBuffer {
    public:
        RECV_STATUS recv_status = RECV_IDLE;
        int message_len;
        int received_len;
        std::string recv_str;
    };

    class Socket {
    protected:
        /* file descriptor */
        int _fd;

    public:
        virtual ~Socket() {};
        virtual SocketTypeEnum GetType() = 0;

        int GetFD() { return _fd; }
    };
    
    /* class for non-blocking listen socket */
    class ListenSocket : public Socket {
    private:
        ListenSocketManager* _manager; 
    public:
        // To create ListenSocket it is highly recommended to use ListenSocketManager
        ListenSocket(int port = DEFAULT_SOCKET_PORT, ListenSocketManager* m = nullptr);

        int DoAccept(); /* do accept and return file descriptor */

        virtual ~ListenSocket();
        virtual SocketTypeEnum GetType() { return SocketTypeEnum::ListenSocket; }
    };
    
    /* class for non-blocking connecting socket */
    class ConnectSocket : public Socket {
    private:
        ConnectSocketManager* _manager;
    public:
        // To create ConnectSocket it is highly recommended to use ConnectSocketManager
        ConnectSocket(std::string domain, ConnectSocketManager* m);

        virtual ~ConnectSocket() {};
        virtual SocketTypeEnum GetType() { return SocketTypeEnum::ConnectSocket; }
    };

    /* class for data-communicating socket */
    class DataSocket : public Socket {
    private:
        SocketRecvBuffer _recvBuff;
        std::list<std::shared_ptr<WriteMsg> > _sendBuff;

        DataSocketManager* _manager; 
    public:
        /* Every data socket are created after the ListenSocket or ConnectSocket 
           are created and estabilished. 
           Thus, constructor of the DataSocket receives the socket fd that
           is generated by ListenSocket or ConnectSocket */
        // To create DataSocket it is highly recommended to use DataSocketManager
        DataSocket(int fd, DataSocketManager* m) { _fd = fd; _manager = m;}

        /* maybe following socket functions can be redesigned in more intuitive ways? 
           or there should be more intuitive interface for user who doesn't need to care 
           about internal buffers such as recvBuff, sendBuff? */
        std::shared_ptr<Message> DoRecv(); /* do recv and return pointer for received Message (if fully received) */
        void DoSend(); /* do actual send (by retrieving the data stream from sendBuff) */
        void AppendMessageToSendBuff(std::shared_ptr<Message> message); /* append a requested message into internal sendBuff */

        virtual ~DataSocket();
        virtual SocketTypeEnum GetType() { return SocketTypeEnum::DataSocket; }
    };

}




#endif

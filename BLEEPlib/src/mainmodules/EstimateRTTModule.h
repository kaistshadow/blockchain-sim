#ifndef ESTIMATE_RTT_MODULE_H
#define ESTIMATE_RTT_MODULE_H

#include "../datamodules/Socket.h"
#include "../datamanagermodules/PeerManager.h"

#include "MainEventManager.h"
#include "../datamodules/Message.h"
#include "../datamodules/Peer.h"
#include "../utility/Assert.h"

#include "shadow_interface.h"
#include <sys/socket.h>

#include <fcntl.h> /* Added for the nonblocking socket */
#include <arpa/inet.h>
#include <netdb.h>

namespace libBLEEP {

#define DEFAULT_SOCKET_PORT 3456
#define BACKLOG 100     /* how many pending connections queue will hold */


#define MESSAGETYPE_RTTREQ 1
#define MESSAGETYPE_RTTREP 2

    class RTTModule_MessageHeader {
    public:
        int length;
        int type;
        int hop;
        PeerId src;
        double timestamp; // time at initial sending
    };

    enum class DoSendResultEnum {
        none,
        SendBuffEmptied,
    };


    class RTTModule_Socket {
    protected:
        /* file descriptor */
        int _fd;

    public:
        virtual ~RTTModule_Socket() {};
        virtual SocketTypeEnum GetType() = 0;

        int GetFD() { return _fd; }
    };

    /* class for non-blocking listen socket */
    class RTTModule_ListenSocket : public RTTModule_Socket {

    public:
        // To create ListenSocket it is highly recommended to use ListenSocketManager
        RTTModule_ListenSocket(int port = DEFAULT_SOCKET_PORT);

        int DoAccept(); /* do accept and return file descriptor */

        virtual ~RTTModule_ListenSocket();
        virtual SocketTypeEnum GetType() { return SocketTypeEnum::ListenSocket; }
    };
    
    /* class for non-blocking connecting socket */
    class RTTModule_ConnectSocket : public RTTModule_Socket {
    public:
        // To create ConnectSocket it is highly recommended to use ConnectSocketManager
        RTTModule_ConnectSocket(std::string domain);

        virtual ~RTTModule_ConnectSocket() {}; // should not be closed. (same fd can be used for dataSocket)
        virtual SocketTypeEnum GetType() { return SocketTypeEnum::ConnectSocket; }
    };

    /* class for data-communicating socket */
    class RTTModule_DataSocket : public RTTModule_Socket {
    private:
        SocketRecvBuffer _recvBuff;
        std::list<std::shared_ptr<WriteMsg> > _sendBuff;

    public:
        SocketRecvBuffer& GetRecvBuff() { return _recvBuff; }
        /* Every data socket are created after the ListenSocket or ConnectSocket 
           are created and estabilished. 
           Thus, constructor of the DataSocket receives the socket fd that
           is generated by ListenSocket or ConnectSocket */
        // To create DataSocket it is highly recommended to use DataSocketManager
        RTTModule_DataSocket(int fd);

        /* maybe following socket functions can be redesigned in more intuitive ways? 
           or there should be more intuitive interface for user who doesn't need to care 
           about internal buffers such as recvBuff, sendBuff? */
        std::pair< bool, std::pair< std::shared_ptr<RTTModule_MessageHeader>, std::shared_ptr<Message> > > DoRecv(); /* do recv and return pointer for received Message (if fully received) */
        DoSendResultEnum DoSend(); /* do actual send (by retrieving the data stream from sendBuff) */
        void AppendMessageToSendBuff(RTTModule_MessageHeader header, std::shared_ptr<Message> message);
        /* void AppendMessageToSendBuff(std::shared_ptr<Message> message, PeerId dest); /\* append a requested message into internal sendBuff *\/ */

        virtual ~RTTModule_DataSocket();
        virtual SocketTypeEnum GetType() { return SocketTypeEnum::DataSocket; }
    };


    class RTTModule_SocketManager {
    private:
        std::map<int, std::shared_ptr<RTTModule_ListenSocket> > _listenSockets;  // map fd -> ListenSocket structure

    public:
        // create listening socket + create IO watcher for it
        int CreateListenSocket(int port = DEFAULT_SOCKET_PORT);

        // should we need method for deleting socket?

        /* get ListenSocket method */
        std::shared_ptr<RTTModule_ListenSocket> GetListenSocket(int fd);

    private:
        std::map<int, std::shared_ptr<RTTModule_DataSocket> > _dataSockets;  // map fd -> ConnectSocket structure

    public:
        // When the CreateDataSocket is called?
        // when receiveConnection event is triggered : accept & create data socket
        // when socketConnected event is triggered : replace connect socket as data socket
        void CreateDataSocket(int sfd);

        // remove data socket from container and remove related IO watcher
        void RemoveDataSocket(int fd);

        /* get DataSocket method */
        std::shared_ptr<RTTModule_DataSocket> GetDataSocket(int fd);
        std::vector<std::shared_ptr<RTTModule_DataSocket> > GetAllDataSockets();

    private:
        std::map<int, std::shared_ptr<RTTModule_ConnectSocket> > _connectSockets;  // map fd -> ConnectSocket structure

    public:
        // create connecting socket + create IO watcher for it
        int CreateNonblockConnectSocket(std::string destination);

        // remove connecting socket and related IO watcher
        void RemoveConnectSocket(int fd);
    };


    class EstimateRTTModule {
    private:
        class ListenSocketWatcher;
        class DataSocketWatcher;
        class ConnectSocketWatcher;

        class WatcherWrapper {
        protected:
            EstimateRTTModule* _networkModule;
            MainEventManager* _mainEventModule;
        public:
            WatcherWrapper(EstimateRTTModule* netModule, MainEventManager* eventModule)
                : _networkModule(netModule), _mainEventModule(eventModule) {};
        };
        class WatcherManager {
        private:
            EstimateRTTModule* _networkModule;
            MainEventManager* _mainEventModule;

            /* event watcher */
            std::map<int, std::shared_ptr<DataSocketWatcher> > _dataSocketWatchers;

        public:
            WatcherManager(EstimateRTTModule* netModule, MainEventManager* eventModule)
                : _networkModule(netModule), _mainEventModule(eventModule) {};
            void CreateDataSocketWatcher(int fd) {
                M_Assert(_dataSocketWatchers.find(fd) == _dataSocketWatchers.end(), "fd must not have duplicated watchers");
                // allocate new DataSocketWatcher
                // and append it into the map structure (_dataSocketWatchers)
                _dataSocketWatchers[fd] = std::make_shared<DataSocketWatcher>(fd, _networkModule, _mainEventModule);
            }

            std::shared_ptr<DataSocketWatcher> GetDataSocketWatcher(int fd) {
                auto it = _dataSocketWatchers.find(fd);
                if (it == _dataSocketWatchers.end()) {
                    std::cout << "No valid dataSocketWatcher exists" << "\n";
                    return nullptr;
                }
                return it->second;
            }

            void RemoveDataSocketWatcher(int fd) {
                auto it = _dataSocketWatchers.find(fd);
                if (it != _dataSocketWatchers.end())
                    _dataSocketWatchers.erase(it);
            }

        };

        class AsyncGenerateRTTMsgTimer : public WatcherWrapper {
        private:
            ev::timer _timer; // destructor automatically stops the watcher
            int _remainingRTTnum;
            void _timerCallback(ev::timer &w, int revents) {
                _networkModule->SendRTTMsg();
                
                if (_remainingRTTnum > 0) 
                    new AsyncGenerateRTTMsgTimer(1, _remainingRTTnum, _networkModule, _mainEventModule);

                delete this;
            }
        public:
        AsyncGenerateRTTMsgTimer(double time, int num, EstimateRTTModule* netModule, MainEventManager* eventModule)
                : WatcherWrapper(netModule, eventModule) {
                _timer.set<AsyncGenerateRTTMsgTimer, &AsyncGenerateRTTMsgTimer::_timerCallback> (this);
                _timer.set(time, 0.);
                _timer.start();
                _remainingRTTnum = num - 1;
                /* std::cout << "timer started!" << "\n"; */
            }
        };

        class AsyncConnectTimer : public WatcherWrapper {
        private:
            ev::timer _timer; // destructor automatically stops the watcher
            PeerId _id;
            void _timerCallback(ev::timer &w, int revents) {
                std::cout << "AsyncConnect timer callback executes!" << "\n";
                _networkModule->AsyncConnectPeer(_id);
                delete this;
            }
        public:
            AsyncConnectTimer(PeerId id, double time, EstimateRTTModule* netModule, MainEventManager* eventModule)
                : WatcherWrapper (netModule, eventModule) {
                _id = id;
                _timer.set<AsyncConnectTimer, &AsyncConnectTimer::_timerCallback> (this);
                _timer.set(time, 0.);
                _timer.start();
                std::cout << "timer started!" << "\n";
            }
        };

        class ListenSocketWatcher : public WatcherWrapper {
        private:
            /* event watcher */
            ev::io _watcher;

            /* event io callback */
            void _listenSocketIOCallback (ev::io &w, int revents) {
                std::cout << "listen socket IO callback called!" << "\n";

                if (revents & EV_READ) {
                    int fd = w.fd;

                    std::shared_ptr<RTTModule_ListenSocket> listenSocket = _networkModule->socketManager.GetListenSocket(fd);

                    // Need to execute accept on listen socket and create data socket
                    // Handle pending 'accept' until there's no remaining accept requests.
                    while (1) {
                        int data_sfd = listenSocket->DoAccept();
                        if (data_sfd == -1)
                            break;
                        /* create new data socket */
                        _networkModule->socketManager.CreateDataSocket(data_sfd);
                        _networkModule->watcherManager.CreateDataSocketWatcher(data_sfd);
                    }
                }
            }
        public:
            ListenSocketWatcher(int fd, EstimateRTTModule* netModule, MainEventManager* eventModule)
                : WatcherWrapper(netModule, eventModule) {
                _watcher.set<ListenSocketWatcher, &ListenSocketWatcher::_listenSocketIOCallback> (this);
                _watcher.start(fd, ev::READ);
            }
        };

        class DataSocketWatcher : public WatcherWrapper {
        private:
            /* socket fd */
            int _fd;

            /* event watcher */
            ev::io _watcher;

            /* event io callback */
            void _dataSocketIOCallback (ev::io &w, int revents) {
                init_shadow_clock_update();
                M_Assert(_fd == w.fd, "fd must be same");
                int fd = w.fd;
                PrintTimespec("dataSocketIOCallback called");

                if (revents & EV_READ) {
                    std::shared_ptr<RTTModule_DataSocket> dataSocket = _networkModule->socketManager.GetDataSocket(fd);

                    // overall process of receiving data
                    // retrieve raw stream data from socket and append them into recvBuffer
                    // retrieve Message from recvBuffer if possible
                    // return Message as asynchronous event

                    std::pair< bool, std::pair< std::shared_ptr<RTTModule_MessageHeader>, std::shared_ptr<Message> >> recvResult = dataSocket->DoRecv();
                    if (!recvResult.first) {
                        // socket closed by remote while doRecv

                        std::shared_ptr<PeerId> disconnectedPeerId = _networkModule->peerManager.GetPeerIdBySocket(fd);
                        // update peermanager for closed socket
                        _networkModule->peerManager.UpdateNeighborSocketDisconnection(fd);

                        if (disconnectedPeerId != nullptr) {
                            // set asynchronous event
                            AsyncEvent event(AsyncEventEnum::PeerDisconnected);
                            event.GetData().SetDisconnectedPeer(disconnectedPeerId);
                            _mainEventModule->PushAsyncEvent(event);
                        }
                        else {
                            // this case is possible
                            // when redundant connection is closed by remote peer
                        }

                        _networkModule->socketManager.RemoveDataSocket(fd);
                        _networkModule->watcherManager.RemoveDataSocketWatcher(fd);
                        // automatically destroyed?
                    }
                    else {
                        // check whether any message is received
                        std::shared_ptr<RTTModule_MessageHeader> header = recvResult.second.first;
                        std::shared_ptr<Message> message = recvResult.second.second;

                        if (header) {
                            std::cout << "recv header after DoRecv. need to set delay for experiment." << "\n";
                            _networkModule->receivedHeader[fd] = header;
                        } else if (message && message->GetType() == "notifyPeerId") {
                            /** received id notify message (First message after socket establishment)    **/
                            /** This message is intended to be not visible to user of EstimateRTTModule.**/
                            /** Thus, we don't set recvMessage asynchronous event.                       **/
                            /** Instead, we only set newPeerConnected event.                             **/

                            // append a peer information
                            _networkModule->peerManager.AppendNeighborPeerConnectedByRemote(message->GetSource().GetId(), fd);

                            std::shared_ptr<PeerId> newlyConnectedNeighborPeer = std::make_shared<PeerId>(message->GetSource());
                            AsyncEvent event(AsyncEventEnum::NewPeerConnected);
                            event.GetData().SetNewlyConnectedPeer(newlyConnectedNeighborPeer);
                            _mainEventModule->PushAsyncEvent(event);
                        }
                        else if (message) {
                            if (message->GetType() == "RTTReq") {
                                PeerId myPeerId = *_networkModule->peerManager.GetMyPeerId();
                                std::shared_ptr<Message> replymsg = std::make_shared<Message>(myPeerId, message->GetSource(), "RTTRep", "");

                                // make dummy header for reply message
                                struct timespec tspec;
                                clock_gettime(CLOCK_MONOTONIC, &tspec);
                                RTTModule_MessageHeader replyheader;
                                replyheader.type = MESSAGETYPE_RTTREP;
                                replyheader.hop = 0;
                                replyheader.src = myPeerId;
                                replyheader.timestamp = tspec.tv_nsec + tspec.tv_sec * 1e9;

                                dataSocket->AppendMessageToSendBuff(replyheader, replymsg);
                                DoSendResultEnum result = dataSocket->DoSend();
                                M_Assert(result == DoSendResultEnum::SendBuffEmptied, "must be sent");
                                int flags = fcntl(fd, F_GETFL, 0);
                                fcntl(fd, F_SETFL, flags |O_NONBLOCK);

                                // append shadow log
                                char buf[256];
                                sprintf(buf, "UnicastMessage,%s,%s,%s,%s",
                                        myPeerId.GetId().c_str(),
                                        replymsg->GetDest().GetId().c_str(),
                                        replymsg->GetType().c_str(),
                                        replymsg->GetMessageId().c_str());
                                shadow_push_eventlog(buf);

                            } else if (message->GetType() == "RTTRep") {
                                int flags = fcntl(fd, F_GETFL, 0);
                                fcntl(fd, F_SETFL, flags |O_NONBLOCK);

                                char buf[256];
                                sprintf(buf, "RTTRep received from %s", message->GetSource().GetId().c_str());
                                PrintTimespec(buf);
                            } else {

                            }

                            // set asynchronous event
                            AsyncEvent event(AsyncEventEnum::RecvMessage);
                            event.GetData().SetReceivedMsg(message);
                            _mainEventModule->PushAsyncEvent(event);

                            // append shadow log
                            std::shared_ptr<PeerId> neighborPeerId = _networkModule->peerManager.GetPeerIdBySocket(fd);
                            std::cout << "message source:" << message->GetSource().GetId() << "\n";
                            M_Assert(neighborPeerId != nullptr, "no neighbor peer exists for given socket");

                            char buf[256];
                            sprintf(buf, "RecvMessage,%s,%s,%s,%s",
                                    neighborPeerId->GetId().c_str(),
                                    _networkModule->peerManager.GetMyPeerId()->GetId().c_str(),
                                    message->GetType().c_str(),
                                    message->GetMessageId().c_str());
                            shadow_push_eventlog(buf);

                        }
                    }

                } else if (revents & EV_WRITE) {
                    std::shared_ptr<RTTModule_DataSocket> dataSocket = _networkModule->socketManager.GetDataSocket(fd);

                    // overall process of sending data
                    // 1. serialize data as payload, to make generic Message containing the payload
                    // 2. serialize Message, and push it to sendBuffer
                    // 3. retrieve raw data from sendBuffer and send them into socket.

                    // write data to dataSocket
                    if (dataSocket->DoSend() == DoSendResultEnum::SendBuffEmptied)
                        UnsetWritable();
                }

                /* next_shadow_clock_update("==== done handling dataSocketIOCallback"); */
                PrintTimespec("dataSocketIOCallback ended");
            }
        public:
            DataSocketWatcher(int fd, EstimateRTTModule* netModule, MainEventManager* eventModule)
                : WatcherWrapper(netModule, eventModule) {
                _watcher.set<DataSocketWatcher, &DataSocketWatcher::_dataSocketIOCallback> (this);
                _watcher.start(fd, ev::READ); // ev::WRITE will be set only when there exists any pending send request.
                _fd = fd;
                std::cout << "dataSocketWatcher created" << "\n";
            }
            ~DataSocketWatcher() {
                std::cout << "destructor called for dataSocketWatcher" << "\n";
            }

            void SetWritable() {
                _watcher.set(_fd, ev::READ | ev::WRITE);
            }

            void UnsetWritable() {
                _watcher.set(_fd, ev::READ);
            }
        };

        class ConnectSocketWatcher : public WatcherWrapper {
        private:
            int _fd;

            /* event watcher */
            ev::io _watcher;

            /* event io callback */
            void _connectSocketIOCallback (ev::io &w, int revents) {
                std::cout << "connect socket IO callback called!!!" << "\n";

                if (revents & EV_READ) {
                    std::cout << "invalid event is triggered. " << "\n";
                    exit(-1);
                } else if (revents & EV_WRITE) {
                    int fd = w.fd;
                    M_Assert(fd == _fd, "fd should be same");

                    // check status of socket
                    int err = 0;
                    socklen_t len = sizeof(err);
                    if (getsockopt(_fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0 ) {
                        perror("getsockopt"); // Solaris pending error?
                        exit(-1);
                    }
                    if (err) {
                        // Get requested information (peerId)
                        auto it = std::find_if( _networkModule->_asyncConnectPeerRequests.begin(), _networkModule->_asyncConnectPeerRequests.end(),
                                                [fd](const std::pair<PeerId, int>& element) {
                                                    return element.second == fd; } );
                        M_Assert(it != _networkModule->_asyncConnectPeerRequests.end(), "connecting event must have matching request");
                        PeerId refusedPeerId = it->first;
                        _networkModule->_asyncConnectPeerRequests.erase(it);

                        // set asynchronous event
                        AsyncEvent event(AsyncEventEnum::ErrorAsyncConnectPeer);
                        event.GetData().SetRefusedPeerId(refusedPeerId);
                        event.GetData().SetError(err);
                        if ( ECONNREFUSED == err ) {
                            event.GetData().SetErrorMsg("connection refused");
                        } else if ( ETIMEDOUT == err) {
                            event.GetData().SetErrorMsg("connection timeout");
                        } else {
                            M_Assert(0, "unknown connection error");
                        }
                        _mainEventModule->PushAsyncEvent(event);


                        _networkModule->socketManager.RemoveConnectSocket(fd);
                        close(fd);
                        delete this;
                        return;
                    }


                    // Get requested information (peerId)
                    auto it = std::find_if( _networkModule->_asyncConnectPeerRequests.begin(), _networkModule->_asyncConnectPeerRequests.end(),
                                            [fd](const std::pair<PeerId, int>& element) {
                                                return element.second == fd; } );
                    M_Assert(it != _networkModule->_asyncConnectPeerRequests.end(), "connecting event must have matching request");
                    PeerId connectedPeerId = it->first;
                    int connectedSocketFD = it->second;
                    _networkModule->_asyncConnectPeerRequests.erase(it);

                    std::shared_ptr<PeerInfo> connPeer = _networkModule->peerManager.GetPeerInfo(connectedPeerId);
                    if (connPeer && connPeer->GetSocketStatus() == SocketStatus::SocketConnected) {
                        // there already exists a connected neighbor peer.
                        // Thus remove newly generate dataSocket(since it's redundant)
                        _networkModule->socketManager.RemoveDataSocket(fd);
                        _networkModule->watcherManager.RemoveDataSocketWatcher(fd);

                        // return ErrorAsyncConnectPeer (redundant connection)
                        // set asynchronous event
                        AsyncEvent event(AsyncEventEnum::ErrorAsyncConnectPeer);
                        event.GetData().SetRefusedPeerId(connectedPeerId);
                        event.GetData().SetError(-1);
                        event.GetData().SetErrorMsg("redundant connection");
                        _mainEventModule->PushAsyncEvent(event);

                        // remove connect socket & socket watcher
                        _networkModule->socketManager.RemoveConnectSocket(fd); /* remove connect socket structure */
                        close(fd);
                        delete this;
                        return;
                    }

                    // Create new dataSocket for new connection
                    _networkModule->socketManager.CreateDataSocket(fd); /* create data socket structure */
                    _networkModule->watcherManager.CreateDataSocketWatcher(fd);

                    // Append connected peer information in peerManager
                    _networkModule->peerManager.AppendNeighborPeerConnectedByMyself(connectedPeerId, connectedSocketFD);

                    /** send id notify message (First message after socket establishment)   **/
                    /** Of course, we use socket for sending this message.                  **/
                    /** However, this message is not visible to user of MainEventManager.   **/
                    std::shared_ptr<Message> firstMsg = std::make_shared<Message>(*_networkModule->peerManager.GetMyPeerId(),
                                                                                  connectedPeerId,
                                                                                  "notifyPeerId", "");
                    std::shared_ptr<RTTModule_DataSocket> dataSocket = _networkModule->socketManager.GetDataSocket(fd);

                    // make header for message
                    struct timespec tspec;
                    clock_gettime(CLOCK_MONOTONIC, &tspec);
                    RTTModule_MessageHeader header;
                    header.type = 0;
                    header.hop = 0;
                    header.src = *_networkModule->peerManager.GetMyPeerId();
                    header.timestamp = tspec.tv_nsec + tspec.tv_sec * 1e9;

                    dataSocket->AppendMessageToSendBuff(header, firstMsg);
                    // set writable for data socket watcher
                    std::shared_ptr<DataSocketWatcher> dataSocketWatcher = _networkModule->watcherManager.GetDataSocketWatcher(fd);
                    if (dataSocketWatcher)
                        dataSocketWatcher->SetWritable();


                    // push asynchronous event
                    AsyncEvent event(AsyncEventEnum::CompleteAsyncConnectPeer);
                    event.GetData().SetConnectedPeerId(connectedPeerId);
                    event.GetData().SetConnectedSocketFD(connectedSocketFD);
                    _mainEventModule->PushAsyncEvent(event);

                    // append shadow log for connection establishment
                    char buf[256];
                    sprintf(buf, "ConnectPeer,%s,%s", _networkModule->peerManager.GetMyPeerId()->GetId().c_str(), connectedPeerId.GetId().c_str());
                    shadow_push_eventlog(buf);

                    // remove connect socket & socket watcher
                    _networkModule->socketManager.RemoveConnectSocket(fd); /* remove connect socket structure */
                    delete this;
                    return;
                }
            }
        public:
            ConnectSocketWatcher(int fd, EstimateRTTModule* netModule, MainEventManager* eventModule)
                : WatcherWrapper(netModule, eventModule) {
                _watcher.set<ConnectSocketWatcher, &ConnectSocketWatcher::_connectSocketIOCallback> (this);
                _watcher.start(fd, ev::WRITE);
                _fd = fd;
            }
        };

    private:
        MainEventManager* _mainEventManager;

        std::map<int, std::shared_ptr<RTTModule_MessageHeader> > receivedHeader;

    public:
        /* Constructor with proper peer id */
        EstimateRTTModule(std::string myPeerId, double sendStarttime, int sendNum, MainEventManager* worker);

        /*********************************************************/
        /* Public API designed for high-level event requests */
        /*********************************************************/

        /* asynchronous API that requests a connection for given peer */
        /* When the task is complete, 'complete event' will be triggered. */
        /* 'complete event' offers connected socket fd and requested PeerId */
        /* If the valid socket connection exists for given PeerId,
           the function immediately returns false, and 'complete event' will not be triggered */
        /* If the 'time' is given, the API tries connection
           after the given 'time' is passed. */
        bool AsyncConnectPeer(PeerId id, double time = 0);

        /* asynchronous API that sends a given message to proper peer(s) */
        /* If the valid socket connection does not exist for given PeerId,
           the function immediately returns false */
        /* There's no separate complete event for this API */
        bool UnicastMessage(PeerId dest, std::shared_ptr<Message> message);

        /* synchronous API that requests a disconnection for given peer */
        /* Since it's synchronous API,
           there's no separate complete event for this API */
        /* If the valid socket connection does not exist for given PeerId,
           the function immediately returns false */
        bool DisconnectPeer(PeerId id);

        void SendRTTMsg();

    private:
        /*********************************************************/
        /* Internal data structures
           for managing the asynchronous function call data.
           Current list of supported asynchronous function calls :
           1) AsyncConnectPeer (supported at 20190328)           */
        /*********************************************************/

        // for managing AsyncConnectPeer's requested data
        std::list<std::pair< PeerId, int > > _asyncConnectPeerRequests;


    private:
        WatcherManager watcherManager;

    private:
        // Internal management module for managing peers
        // It maintains the table of the all known peers having valid socket connection
        PeerManager peerManager;

    private:
        /*********************************************************/
        /* Internal management modules for managing sockets */
        /*********************************************************/

        /*************** for socket-IO event handling ******************/
        RTTModule_SocketManager socketManager;

    };

}

#endif
